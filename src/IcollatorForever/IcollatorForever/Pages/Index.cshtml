<!--
Copyright (c) 2019 Andrew Vardeman.  Published under the MIT license.
See license.txt in the IcollatorForever distribution or repository for the
full text of the license.
-->

@page "/"

<div id="inputContainer">
    <div><input id="mainFileInput" class="fileInput" type="file" accept="image/x-icon" multiple /></div>
    <div class="topButtons">
        <label id="chooseFileLabel" class="fileInputLabel btn btn-primary" for="mainFileInput">Add File(s)...</label>
        <button id="clearButton" class="btn btn-primary" onclick="clearTable()" disabled=@NoEntries>Clear</button>
        <button id="saveButton" class="btn btn-primary" onclick="saveFile()" disabled=@NoEntries>Save to .ico</button>
    </div>
</div>
<div id="iconTableContainer">
    @if (_entries.Count > 0)
    {
        <table>
            <thead>
                <tr>
                    <th>XOR Image</th>
                    <th>AND Image</th>
                    <th>Source File Name</th>
                    <th>Source Index</th>
                    <th>Width</th>
                    <th>Height</th>
                    <th>Bit Count</th>
                    <th>Color Count</th>
                    <th>Size in Bytes</th>
                </tr>
            </thead>
            <tbody>
                @for (int i = 0; i < _entries.Count; i++)
                {
                    IIconEntry entry = _entries[i];
                    string onclick = $"select({i})";
                    IconEntryDescription description = entry.Description;
                    <tr onclick="@onclick" class="@(entry == _selectedEntry ? "selected" : "")">
                        @if (entry.HasAndImage)
                        {
                            <td><img src="@entry.XorDataUrl" /></td>
                            <td><img src="@entry.AndDataUrl" /></td>
                        }
                        else
                        {
                            <td colspan="2"><img src="@entry.XorDataUrl" title="PNGs are supported but not displayed" /></td>
                        }
                        <td>@description.SourceFileName</td>
                        <td>@description.SourceIndex</td>
                        <td>@description.Width</td>
                        <td>@description.Height</td>
                        <td>@description.BitCount</td>
                        <td>@description.ColorCount</td>
                        <td>@description.SizeInBytes</td>
                    </tr>
                }
            </tbody>
        </table>
    }
    @foreach (Exception ex in _exceptions)
    {
        <p>@ex.ToString()</p>
    }
</div>
<div id="selectedEntryActions" class='bottomButtons @(NoSelection ? "" : "entrySelected")'>
    <button id="deleteButton" class="btn btn-primary" onclick="deleteSelected()" disabled=@NoSelection>Delete</button>
</div>

@functions {
    static Index _instance;

    IIconEntry _selectedEntry;

    bool NoEntries => _entries.Count == 0;

    bool NoSelection => _selectedEntry == null;

    List<IIconEntry> _entries = new List<IIconEntry>();

    List<Exception> _exceptions = new List<Exception>();


    [JSInvokable("AddFile")]
    public static void AddFile(string filename, string base64contents)
    {
        _instance.TryAddFile(filename, base64contents);
    }

    [JSInvokable("Clear")]
    public static void Clear()
    {
        _instance.ClearEntries();
    }

    [JSInvokable("DeleteSelected")]
    public static void DeleteSelected()
    {
        _instance.DeleteSelectedEntry();
    }

    [JSInvokable("Select")]
    public static void Select(int index)
    {
        _instance.SelectEntry(index);
    }

    [JSInvokable("GenerateBase64IcoString")]
    public static string GenerateBase64IcoString()
    {
        return _instance.GenerateBase64Ico();
    }

    private void TryAddFile(string filename, string base64contents)
    {
        byte[] contents = Convert.FromBase64String(base64contents);
        try
        {
            using (MemoryStream stream = new MemoryStream(contents))
            {
                Icon icon = new Icon(filename, stream);
                _entries.AddRange(icon.Entries);
            }
            //System.out.println("on file " + i);
        }
        catch (Exception e)
        {
            _exceptions.Add(e);
        }
        _entries = _entries.OrderBy(e => e.Description).ToList();

        StateHasChanged();
    }

    private string GenerateBase64Ico()
    {
        if (_entries.Count > 0)
        {
            using (MemoryStream stream = new MemoryStream())
            {
                IconUtils.WriteToStream(_entries, stream);
                return Convert.ToBase64String(stream.GetBuffer());
            }
        }
        return null;
    }

    private void ClearEntries()
    {
        _entries.Clear();
        _selectedEntry = null;
        StateHasChanged();
    }

    private void DeleteSelectedEntry()
    {
        if (_selectedEntry != null)
        {
            _entries.Remove(_selectedEntry);
            _selectedEntry = null;
            StateHasChanged();
        }
    }

    private void SelectEntry(int index)
    {
        if (index > -1 && index < _entries.Count)
        {
            IIconEntry entry = _entries[index];
            if (entry == _selectedEntry)
            {
                _selectedEntry = null;
            }
            else
            {
                _selectedEntry = entry;

            }
        }
        StateHasChanged();
    }

    protected override void OnInit()
    {
        _instance = this;
        base.OnInit();
    }
}