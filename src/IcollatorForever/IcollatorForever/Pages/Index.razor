@page "/"
@using System.Threading;
@using System.IO;

<!--
Copyright (c) 2019 Andrew Vardeman.  Published under the MIT license.
See license.txt in the IcollatorForever distribution or repository for the
full text of the license.
-->

<div id="inputContainer">
    <div><input id="mainFileInput" class="fileInput" type="file" accept="image/x-icon" multiple /></div>
    <div class="topButtons">
        <label id="chooseFileLabel" class="fileInputLabel btn btn-primary" for="mainFileInput">Add File(s)...</label>
        <button id="clearButton" class="btn btn-primary" onclick="clearTable()" disabled=@NoEntries>Clear</button>
        <button id="saveButton" class="btn btn-primary" onclick="saveFile()" disabled=@NoEntries>Save to .ico</button>
    </div>
</div>
<div id="iconTableContainer" ondrop="handleDrop(event); return false;" ondragover="return handleDragOver(event);"
     ondragenter="return handleDragEnter(event);" ondragleave="return handleDragLeave(event);">
    @if (_entries.Count == 0)
    {
        <div id="dropTarget">Drag and drop files here to add them to your icon.</div>
    }
    @if (_entries.Count > 0)
    {
        <table>
            <thead>
                <tr>
                    <th>XOR Image</th>
                    <th>AND Image</th>
                    <th>Source File Name</th>
                    <th>Source Index</th>
                    <th>Width</th>
                    <th>Height</th>
                    <th>Bit Count</th>
                    <th>Color Count</th>
                    <th>Size in Bytes</th>
                </tr>
            </thead>
            <tbody>
                @for (int i = 0; i < _entries.Count; i++)
                {
                    IIconEntry entry = _entries[i];
                    string clickHandler = $"select({i})";
                    IconEntryDescription description = entry.Description;
                    <tr onclick="@clickHandler" class="@(entry == _selectedEntry ? "selected" : "")">
                        @if (entry.HasAndImage)
                        {
                            <td><img src="@entry.XorDataUrl" /></td>
                            <td><img src="@entry.AndDataUrl" /></td>
                        }
                        else
                        {
                            <td colspan="2"><img src="@entry.XorDataUrl" title="PNGs are supported but not displayed" /></td>
                        }
                        <td>@description.SourceFileName</td>
                        <td>@description.SourceIndex</td>
                        <td>@description.Width</td>
                        <td>@description.Height</td>
                        <td>@description.BitCount</td>
                        <td>@description.ColorCount</td>
                        <td>@description.SizeInBytes</td>
                    </tr>
                }
            </tbody>
        </table>
    }
    @foreach (Exception ex in _exceptions)
    {
        <p>@ex.ToString()</p>
    }
</div>
<div id="selectedEntryActions" class='bottomButtons @(NoSelection ? "" : "entrySelected")'>
    <button id="deleteButton" class="btn btn-primary" onclick="deleteSelected()" disabled=@NoSelection>Delete</button>
</div>

@code {
    static Index _instance;

    IIconEntry _selectedEntry;

    bool NoEntries => _entries.Count == 0;

    bool NoSelection => _selectedEntry == null;

    TaskCompletionSource<bool> _currentFileTaskCompletionSource;

    byte[] _currentFileContents;

    Timer _timer;

    List<IIconEntry> _entries = new List<IIconEntry>();

    List<Exception> _exceptions = new List<Exception>();




    [JSInvokable("AddFile")]
    public static async Task<bool> AddFile(string filename, string base64contents)
    {
        Console.WriteLine("AddFile!");
        bool result = await _instance.TryAddFile(filename, base64contents);
        Console.WriteLine("result of TryAddFile = " + result);
        return result;
    }

    [JSInvokable("Clear")]
    public static void Clear()
    {
        _instance.ClearEntries();
    }

    [JSInvokable("DeleteSelected")]
    public static void DeleteSelected()
    {
        _instance.DeleteSelectedEntry();
    }

    [JSInvokable("Select")]
    public static void Select(int index)
    {
        Console.WriteLine("Select " + index);
        _instance.SelectEntry(index);
    }

    [JSInvokable("GenerateBase64IcoString")]
    public static string GenerateBase64IcoString()
    {
        return _instance.GenerateBase64Ico();
    }

    private async Task<bool> TryAddFile(string filename, string base64contents)
    {
        byte[] fileBytes = Convert.FromBase64String(base64contents);

        string extension = System.IO.Path.GetExtension(filename).ToLower();

        bool success = false;

        if (extension == null || extension.Length == 0 || extension == ".ico")
        {
            success = TryAddIcoFile(filename, fileBytes);

            StateHasChanged();

            return await Task.FromResult(success);
        }
        if (!success)
        {
            // if (extension == ".dll")
        }

        

        return await Task.FromResult(false);

        //_timer = new Timer(new TimerCallback(_ =>
        //{


        //    StateHasChanged();
        //}), null, 10, 10);


        //return _currentFileTaskCompletionSource.Task;

    }

    private bool TryAddIcoFile(string filename, byte[] bytes)
    {
        try
        {
            using (MemoryStream stream = new MemoryStream(bytes))
            {
                Icon icon = new Icon(filename, stream);
                _entries.AddRange(icon.Entries);
                _entries = _entries.OrderBy(e => e.Description).ToList();
                StateHasChanged();
            }
            return true;
        }
        catch (Exception e)
        {
            _exceptions.Add(e);
            StateHasChanged();
        }
        return false;
    }

    private string GenerateBase64Ico()
    {
        if (_entries.Count > 0)
        {
            using (MemoryStream stream = new MemoryStream())
            {
                IconUtils.WriteToStream(_entries, stream);
                return Convert.ToBase64String(stream.GetBuffer());
            }
        }
        return null;
    }

    private void ClearEntries()
    {
        _entries.Clear();
        _selectedEntry = null;
        StateHasChanged();
    }

    private void DeleteSelectedEntry()
    {
        if (_selectedEntry != null)
        {
            _entries.Remove(_selectedEntry);
            _selectedEntry = null;
            StateHasChanged();
        }
    }

    private void SelectEntry(int index)
    {
        Console.WriteLine("SelectEntry " + index);
        if (index > -1 && index < _entries.Count)
        {
            IIconEntry entry = _entries[index];
            if (entry == _selectedEntry)
            {
                _selectedEntry = null;
            }
            else
            {
                _selectedEntry = entry;
            }
        }
        StateHasChanged();
    }

    protected override void OnInit()
    {
        _instance = this;
        base.OnInit();
    }
}